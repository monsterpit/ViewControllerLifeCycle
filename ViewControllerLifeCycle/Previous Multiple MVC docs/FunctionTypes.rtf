{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Bold;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Menlo-Italic;}
{\colortbl;\red255\green255\blue255;\red128\green0\blue128;\red255\green255\blue255;\red0\green0\blue0;
\red92\green38\blue153;\red64\green128\blue2;\red50\green109\blue116;\red28\green0\blue207;\red57\green0\blue160;
}
{\*\expandedcolortbl;;\csgenericrgb\c50196\c0\c50196;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0;
\csgenericrgb\c35922\c14825\c60191;\csgenericrgb\c25098\c50194\c896;\csgenericrgb\c19418\c42935\c45455;\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c22454\c0\c62803;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \ul \ulc0 Function types\
\ulnone \
Functions are types .\
You can declare a variable (or parameter to a method or whatever) to be of type "function"\
You'll declare it with the types of the functions arguments(and return type) included\
\
Example :-\
\
var operation : (Double) -> Double   i.e.(
\f1\b \cf2 \cb3 var
\f2\b0 \cf4  operation : ((\cf5 Double\cf4 ) -> \cf5 Double\cf4 )!
\f0 \cf0 \cb1 )\
This is a var called operation\
It is of type "function that takes a Double and returns a Double"\
\
You can assign it like any other variable ...\
\
operation - sqrt //sqrt is just a function that takes a double and returns a double\
\
You can "call" this function using syntax very similar to any function call...\
\
let result = operation(4.0) //result will be 2.0\
\
Other languages has function pointer and all stuffs, in swift functions are first class citizen they can be arguments to many iOS functions\
\
\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	\uc0\u8226 	}
\b Closure\
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf0 Often you want to create the functions "on the fly" (rather than already existing like sqrt)\
You can do this "in line using a closure"\
\
//Dummy example to consider before making closure\
//Imagine we had function that changed the sign of its argument ..\

\b func changeSign(operand : Double) -> Double \{return -operand\}
\b0 \
\
We could use it instead of sqrt ...\

\b var operation : (Double) -> Double\
operation = changeSign\
let result = operation(4.0) //result will be -4.0\
\
\
Closure is kinda like inline function\

\b0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 we can "in line" 
\b changeSign 
\b0 simply by moving the function (without its name) below ...\
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf0 operation =(operand : Double) -> Double \{return -operand\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\b0 \cf0 but we have to make 1 syntactic change here \
Move the first  \{ to the start and replace with in\
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf0 operation = \{(operand : Double) -> Double in return -operand\}\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i\b0 \cf6 \cb3 But it can get much better has we have type inference in swift\
\
//But it can get much better has we have type inference in swift
\f0\i0 \cf0 \
\

\f3\i \cf6 //Swift knows this operation thing returns a Double
\f0\i0 \cf0 \
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 var
\f2\b0 \cf4  operation3 : (\cf5 Double\cf4 ) -> \cf5 Double\cf4  = \{(operand : \cf5 Double\cf4 ) 
\f1\b \cf2 in
\f2\b0 \cf4  
\f1\b \cf2 return
\f2\b0 \cf4  -operand\}
\f0 \cf0 \

\f1\b \cf2 let
\f2\b0 \cf4  result3 = \cf7 operation3\cf4 (\cf8 4.0\cf4 )\
\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i \cf6 //It also knows its operands are Double
\f0\i0 \cf0 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 var
\f2\b0 \cf4  operation4 : (\cf5 Double\cf4 ) -> \cf5 Double\cf4  = \{(operand) 
\f1\b \cf2 in
\f2\b0 \cf4  
\f1\b \cf2 return
\f2\b0 \cf4  -operand\}
\f0 \cf0 \

\f1\b \cf2 let
\f2\b0 \cf4  result4 = \cf7 operation3\cf4 (\cf8 4.0\cf4 )\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i \cf6 //It also knows that operation returns a value, so the return keyword is unnecessary
\f0\i0 \cf0 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 var
\f2\b0 \cf4  operation5 : (\cf5 Double\cf4 ) -> \cf5 Double\cf4  = \{(operand) 
\f1\b \cf2 in
\f2\b0 \cf4   -operand\}
\f0 \cf0 \

\f1\b \cf2 let
\f2\b0 \cf4  result5 = \cf7 operation3\cf4 (\cf8 4.0\cf4 )\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i \cf6 //swift knows you need embedded functions all the time and its little annoying to think of the names for the argument to "operand" thing. So its lets you substitute $0,$1,$2 .... and we can skip "in"
\f0\i0 \cf0 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 var
\f2\b0 \cf4  operation6 : (\cf5 Double\cf4 ) -> \cf5 Double\cf4  = \{-$0\}
\f0 \cf0 \

\f1\b \cf2 let
\f2\b0 \cf4  result6 = \cf7 operation3\cf4 (\cf8 4.0\cf4 )
\f0 \cf0 \
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i \cf6 //$0,$1 are shorthand notations\
\
\
Where do we use closures?\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\i0\b \cf2 Often as arguments to methods.\
Many times a method want to know "
\f3\i\b0 \cf6 what to do
\f1\i0\b \cf2 " and providing a function tells it what to do\
For example, what to do when there's an error or when something asynchronous finishes\
Or may be you want to ask method to repeatedly perform a function\
\
functions need what to do ? and closure are great way to provide what to do? for a function\

\f2\b0 \cf4 what to do when there is an  error or when its gonna do something that takes a long time(go in network and download something off in a background and when its done it wants to tell it)\
what to do over and over again\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf0 \cb1 Array has a method called map which takes a function as an argument.\
It applies that function to each element of the Array to create and return a new Array\
map is way to pass a function to a array and tell it to do it on every element
\f2\b0 \cf4 \cb3 \
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 let
\f2\b0 \cf4  primes = [\cf8 2.0\cf4 ,\cf8 3.0\cf4 ,\cf8 5.0\cf4 ,\cf8 7.0\cf4 ,\cf8 11.0\cf4 ]
\f0 \cf0 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i \cf6 //let negativePrimes = primes.map(<#T##transform: (Double) throws -> T##(Double) throws -> T#>)
\f0\i0 \cf0 \

\f3\i \cf6 //let negativePrimes = primes.map \{ (<#Double#>) -> T in
\f0\i0 \cf0 \

\f3\i \cf6 //    <#code#>
\f0\i0 \cf0 \

\f3\i \cf6 //\}
\f0\i0 \cf0 \

\f3\i \cf6 //let negativePrimes = primes.map \{ (<#Double#>)  in
\f0\i0 \cf0 \

\f3\i \cf6 //    <#code#>
\f0\i0 \cf0 \

\f3\i \cf6 //\}
\f0\i0 \cf0 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 let
\f2\b0 \cf4  negativePrimes = \cf7 primes\cf4 .\cf9 map\cf4  (\{ -$0 \})
\f0 \cf0 \

\f1\b \cf2 let
\f2\b0 \cf4  invertedPrimes = \cf7 primes\cf4 .\cf9 map\cf4 () \{ \cf8 1.0\cf4 /$0 \}
\f0 \cf0 \

\f1\b \cf2 let
\f2\b0 \cf4  primeString = \cf7 primes\cf4 .\cf9 map\cf4  \{ \cf5 String\cf4 ($0) \}\
\
\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i \cf6 //Trailing Closure Syntax(if the last argument to any function is a closure you can move the closure outside the parenthesis and if its the only argument then you can get rid of parenthesis entirely )
\f2\i0 \cf4 \
Note that 
\f1\b \cf2 if
\f2\b0 \cf4  last(or only) argument to a method 
\f1\b \cf2 is
\f2\b0 \cf4  a closure,you can put it outside the method's paranthesis that contain its arguments and if the closure was the only argument,you can skip the () completely if you want\
\
//usually in iOS if the argument to a function is a function it will usually be the last argument so you can move it outside the parenthesis though its optional\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 Another cool use of closure is property initialization\
\
You can also execute closure to do initialization of property if you want..\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f3\i\b0 \cf6 var someProperty : Type = \{\
//construct the value of someProperty here\
return <the constructed value>\
\}()\
\
This is especially useful with 
\f1\i0\b \cf2 lazy
\f3\i\b0 \cf6  property initialization\
\
You cant do a one line thing in initialization like var a = 5 (you need 2 or 3 lines of code to get it initialized) \
No problem you are allowed to set the property initialization to executing a closure. \
This closure will automatically be a closure that takes no arguments and returns the right type to initialize that property\
And you execute it right way with ()\
\
\
Capturing\
\
Closures are regular types,so they can be put in Arrays,Dictionarys,etc.\
When this happens , they are stored in the heap(i.e. they are reference types)\
\
There are only 2 reference types in swift (classes and closures)\
\
\
\
\
What is more they "capture" variables they use from the surrounding code into the heap too.\
Those captured variables need to stay in the heap as long as the closure stay in the heap.\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0
\cf6 \cb3 //Closure  Memory Leaks
\f0\i0 \cf0 \

\f1\b \cf2 var
\f2\b0 \cf4  ltuae = \cf8 42.0
\f0 \cf0 \

\f1\b \cf2 var
\f2\b0 \cf4  operation7 : (\cf5 Double\cf4 ) -> \cf5 Double\cf4  = \{\cf7 ltuae\cf4  * $0\}
\f0 \cf0 \

\f3\i \cf6 //captures the ltuae var because its needed for this closure
\f0\i0 \cf0 \

\f1\b \cf2 var
\f2\b0 \cf4  arrayOfOperations : [(\cf5 Double\cf4 )->\cf5 Double\cf4 ]!
\f0 \cf0 \

\f2 \cf7 arrayOfOperations\cf4 .\cf9 append\cf4 (\cf7 operation7\cf4 )\
\
//If we later change ltuae, then the next time we evaluate operation it will reflect that\
//even if we leave the scope (function or whatever) that this code is in\
\
This can create a memory cycle though
\f3\i \cf6 \cb3 \
}